# High-Level Plan: Firebase & React-Vite Application (Simplified Scope)

This document outlines a high-level plan for developing an initial application using Firebase (Firestore) as the backend and React-Vite for the frontend. The primary purpose of this initial build is for **data entry** of appraisal information, **secure storage** in Firebase (focusing on `appraisals`, `appraisal_logs`, `locations`, and `report_utilities` collections), **data review** by users, and enabling users to **select/mark data points for future report inclusion**. The actual functionality to build or generate deliverable reports is deferred.

## 1. Firebase (Firestore) Data Modeling

The following structure is proposed for Firestore, prioritizing scalability and query efficiency for data entry, storage, and review. `appraisal_id` will serve as a key identifier.

### Collections:

*   **`appraisals` (representing `appraisal_unified`)**
    *   **Description**: This will be the central collection holding all unified appraisal data. Each document represents a single appraisal, primarily for data input and detailed review.
    *   **Document ID**: Use the unique `appraisal_id`.
    *   **Fields**:
        *   `appraisal_id` (string, also document ID)
        *   `creation_date` (timestamp)
        *   `client_name` (string)
        *   `property_address` (string, potentially denormalized from `locations`)
        *   `status` (string, e.g., "data_entry", "review_pending", "review_complete")
        *   `assigned_user_id` (string, reference to a users collection if applicable)
        *   `location_ref` (reference, to `locations` collection document)
        *   `selected_for_report` (map, optional, to store flags or references for data points/sections marked for report inclusion)
        *   ... (other fields from `appraisal_general.csv`, `appraisal_jobs.csv`, etc., unified here)
    *   **Subcollections (Optional but Recommended for related granular data):**
        *   `contacts` (if multiple contacts per appraisal, from `appraisal_contacts.csv`)
        *   `buildings` (if multiple buildings, from `building.csv`)
        *   `attachments` (metadata for attachments, from `attachments.csv`)

*   **`appraisal_logs`**
    *   **Description**: A top-level collection to store all log entries across all appraisals. This allows for global log querying (e.g., by date, user, type of action related to data entry or review) and avoids making individual appraisal documents too large.
    *   **Document ID**: Auto-generated by Firestore.
    *   **Fields**:
        *   `appraisal_id` (string, indexed, to link back to the `appraisals` collection)
        *   `timestamp` (timestamp, indexed)
        *   `user_id` (string, who performed the action)
        *   `action_description` (string, e.g., "Data field X updated", "Status changed to 'review_complete'")
        *   `details` (map, for any additional structured log data)

*   **`locations`**
    *   **Description**: A top-level collection for storing detailed location information, primarily for association with appraisals during data entry and for review.
    *   **Document ID**: Auto-generated by Firestore or a unique location identifier if available.
    *   **Fields**:
        *   `address_line1` (string)
        *   `address_line2` (string, optional)
        *   `city` (string)
        *   `state` (string)
        *   `zip_code` (string)
        *   `county` (string)
        *   `latitude` (number)
        *   `longitude` (number)
        *   ... (other fields from `location.csv`)

*   **`report_utilities`**
    *   **Description**: A top-level collection for storing utility items like pre-defined text blocks, standard phrases, or configuration settings that can be **selected for inclusion** in a future report. This is not for managing report generation templates in this phase.
    *   **Document ID**: A descriptive ID (e.g., `standard_disclaimer_01`, `market_condition_text_block_A`).
    *   **Fields**:
        *   `utility_name` (string, descriptive)
        *   `type` (string, e.g., "selectable_disclaimer", "selectable_text_block", "report_inclusion_setting")
        *   `content` (string or map, the actual text or setting to be included)
        *   `category` (string, optional, for organization e.g., "Legal", "Market Analysis")
        *   `version` (number, optional)
        *   ... (other fields from `report_utilities.csv`)

### Relationships and Identifiers:

*   **`appraisal_id`**: This is the cornerstone. It will be the document ID for records in the `appraisals` collection.
*   In `appraisal_logs`, `appraisal_id` will be a field to link back to the specific appraisal. This field should be indexed for efficient querying of logs for a particular appraisal.
*   In `appraisals`, a `location_ref` field (Firestore Reference type) can link to a document in the `locations` collection.

### Denormalization Strategies:

*   **Purpose**: To optimize read performance for data review and reduce complex queries.
*   **Examples**:
    *   Embed a summary of the location (e.g., `property_address_full_string`) directly within the `appraisals` document for quick display in lists.
    *   If displaying the latest log entry or a count of log entries for an appraisal is common for review, these could be denormalized into the `appraisals` document.
*   **Considerations**: Denormalization adds complexity to writes but can significantly improve read speeds for review purposes. Use judiciously.

## 2. Initial React-Vite Frontend Structure

A modular component-based architecture is recommended, focusing on data input, review, and selection functionalities.

### Core Directories:

*   `src/components/`: Reusable UI components (buttons, inputs, cards, data display elements, selection controls).
*   `src/views/` (or `src/pages/`): Top-level page components corresponding to routes, primarily for data entry and review.
*   `src/layouts/`: Layout components (e.g., `MainLayout` with header, sidebar, content area).
*   `src/services/`: Firebase interaction logic (e.g., `firebaseService.js`, `appraisalService.js`).
*   `src/contexts/` (or `src/store/`): For state management (e.g., React Context API, Zustand, Redux Toolkit).
*   `src/hooks/`: Custom React hooks.
*   `src/routes/`: Route definitions.
*   `src/utils/`: Utility functions.
*   `src/assets/`: Static assets like images, global styles.

### Key Components/Views:

*   **Appraisal Data Management & Review:**
    *   `AppraisalListView.jsx`: Displays a list/table of appraisals for overview and navigation. Supports pagination, sorting, filtering to find appraisals for review or further data entry.
    *   `AppraisalDetailView.jsx`: Shows comprehensive details of a selected appraisal for thorough review.
        *   Displays all core appraisal information from the `appraisals` collection.
        *   Includes UI elements (e.g., checkboxes, buttons) to mark specific data fields, sections, or associated items (like selected buildings or contacts) for future report inclusion.
        *   Includes a section or tab for `AppraisalLogList.jsx` (filtered for the current `appraisal_id`) to review history.
        *   Displays linked `LocationInfo.jsx` (or similar component for displaying location details associated with the appraisal).
    *   `AppraisalForm.jsx`: A comprehensive form for creating new appraisals and editing existing ones, focusing on efficient data input. This form will include fields for entering/editing location data associated with the appraisal.
*   **Log Viewing:**
    *   `AppraisalLogList.jsx`: Displays log entries, filterable by `appraisal_id`, primarily for audit and review purposes.
*   **Report Item Selection:**
    *   `ReportUtilitySelectorView.jsx`: Allows users to browse and select items from the `report_utilities` collection (e.g., standard text blocks, disclaimers) to be associated with an appraisal for future report inclusion. This view focuses on selection, not management or template building.
    *   Could include components like `UtilityItemCard.jsx` or `UtilityItemPicker.jsx`.
*   **Shared Components:**
    *   `Navbar.jsx`, `Sidebar.jsx`, `Footer.jsx`
    *   `DataInput.jsx`, `DataDisplayField.jsx`, `SelectionToggle.jsx`
    *   `DataTable.jsx`, `Modal.jsx`, `Spinner.jsx`
    *   `LocationInfo.jsx` (for displaying location data within appraisal views)

### Routing:

*   Utilize `react-router-dom` for client-side routing.
*   Example Routes:
    *   `/` or `/dashboard`: Main dashboard, perhaps showing recent appraisals or tasks.
    *   `/appraisals`: `AppraisalListView`.
    *   `/appraisals/new`: `AppraisalForm` for creation.
    *   `/appraisals/:appraisalId`: `AppraisalDetailView` for review and selection.
    *   `/appraisals/:appraisalId/edit`: `AppraisalForm` for editing.
    *   `/select-report-items/:appraisalId`: `ReportUtilitySelectorView` (or integrated into `AppraisalDetailView`).

## 3. Key Development Steps / Roadmap (Simplified Scope)

This roadmap outlines major phases for the initial build, focusing on data entry, review, and selection.

*   **Phase 1: Project Setup & Foundation (1-2 Weeks)**
    1.  **Firebase Project Creation**: Set up Firestore database, Authentication.
    2.  **Firestore Security Rules**: Define initial security rules for the four core collections.
    3.  **React-Vite Project Initialization**: Create the React project using Vite.
    4.  **Firebase SDK Integration**: Install and configure the Firebase SDK in the React app.
    5.  **Basic UI Layout**: Implement main layout components (Navbar, Sidebar).
    6.  **Version Control**: Setup Git repository.

*   **Phase 2: Core Data Model Implementation & Backend Logic (2-3 Weeks)**
    1.  **Finalize Firestore Schema**: Implement the defined collections (`appraisals`, `appraisal_logs`, `locations`, `report_utilities`) and fields.
    2.  **Firebase Functions (Optional)**: Develop any necessary Cloud Functions for backend logic (e.g., data validation triggers, simple denormalization for review).
    3.  **Service Layer**: Create JavaScript/TypeScript services in React for interacting with Firestore (CRUD operations for the core collections).

*   **Phase 3: Appraisal Data Entry & Review Feature Development (3-4 Weeks)**
    1.  **Appraisal List View**: Develop the UI to display appraisals for navigation and status overview.
    2.  **Appraisal Create/Edit Form**: Develop the comprehensive form for data input, including fields for location data.
    3.  **Appraisal Detail View**: Develop the UI to display full appraisal details for review, including UI elements for selecting data/items for future report inclusion and display of associated location data.
    4.  **State Management**: Implement state management for appraisal data.

*   **Phase 4: Supporting Features Development (2-3 Weeks)**
    1.  **Appraisal Log Integration**: Develop UI to display logs related to an appraisal for review.
    2.  **Location Data Integration**: Focus on developing UI components for entering and editing location data directly *within* the [`AppraisalForm.jsx`](AppraisalForm.jsx:103) and for displaying it (e.g., via a [`LocationInfo.jsx`](LocationInfo.jsx:116) component or similar) *within* the [`AppraisalDetailView.jsx`](AppraisalDetailView.jsx:97). Standalone location management views are explicitly out of scope for this phase.
    3.  **Report Utility Item Selection Integration**: Develop UI to browse and select items from `report_utilities` to associate with an appraisal (e.g., `ReportUtilitySelectorView.jsx`).
    4.  **User Authentication**: Implement user login/logout.

*   **Phase 5: Routing & Navigation (1 Week)**
    1.  **Implement Client-Side Routing**: Set up all necessary routes using `react-router-dom`.
    2.  **Navigation UI**: Ensure seamless navigation between data entry, review, and selection views.

*   **Phase 6: Data Import (1-2 Weeks, can overlap)**
    1.  **Develop Import Scripts**: Create scripts (e.g., Node.js with Firebase Admin SDK) to parse CSVs and import data into the four core Firestore collections, mapping to the new schema.
    2.  **Test Import Process**: Thoroughly test with sample data.
    3.  **Execute Full Data Import**: Perform the import for existing data relevant to the initial scope.

*   **Phase 7: Testing, Refinement & Deployment (2-3 Weeks)**
    1.  **Unit & Integration Testing**: Write tests for components, services, focusing on data input, validation, storage, retrieval, and selection mechanisms.
    2.  **End-to-End Testing**: Test key user flows for data entry, review, and item selection.
    3.  **User Acceptance Testing (UAT)**: Get feedback from stakeholders on the data handling capabilities.
    4.  **Bug Fixing & Performance Optimization** for data operations.
    5.  **Deployment**: Deploy Firebase rules, functions (if any), and the React-Vite frontend (e.g., to Firebase Hosting).

## 4. Data Import Strategy

Migrating existing CSV data into the new Firestore structure is a critical step for populating the system for data entry, review, and selection.

### Recommended Approach: Node.js Script with Firebase Admin SDK

1.  **Environment Setup**:
    *   Install Node.js.
    *   Set up a new Node.js project (`npm init`).
    *   Install `firebase-admin` and a CSV parsing library (e.g., `csv-parser`).
2.  **Service Account**:
    *   Generate a private key file (service account JSON) from your Firebase project settings.
    *   Initialize the Firebase Admin SDK in your script using this key.
3.  **Script Logic (for each CSV corresponding to a target collection: `appraisals`, `appraisal_logs`, `locations`, `report_utilities`):**
    *   **Read CSV**: Use a library like `csv-parser` to read CSV files row by row.
    *   **Transform Data**: For each row, transform the data into the JSON structure required by your Firestore collections. This includes:
        *   Mapping CSV column names to Firestore field names.
        *   Converting data types (e.g., strings to numbers, date strings to Firestore Timestamps).
        *   Handling relationships as defined in the data model.
    *   **Batch Writes**: Use Firestore batch writes to import data efficiently.
    *   **Error Handling**: Implement robust error logging.
    *   **Incremental Imports (if needed)**: Design scripts to be re-runnable if possible.

### Example Workflow for `appraisals` and `locations`:

1.  **Import `locations.csv`**:
    *   Read each row from `location.csv`.
    *   Transform it into the `locations` collection schema.
    *   Batch write to the `locations` collection.
2.  **Import data for `appraisals` (e.g., from `appraisal_general.csv`):**
    *   Read each row.
    *   Extract/generate the `appraisal_id`.
    *   If the appraisal has a related location, look up the corresponding Firestore document ID for that location. Store this as `location_ref`.
    *   Assemble the rest of the `appraisals` document.
    *   Batch write to the `appraisals` collection using `appraisal_id` as the document ID.
3.  **Import `appraisal_log.csv`**:
    *   Read each row.
    *   Extract `appraisal_id` and other log data.
    *   Create a new document in the `appraisal_logs` collection.
4.  **Import `report_utilities.csv`**:
    *   Read each row.
    *   Transform into the `report_utilities` schema, ensuring `content` and `type` align with selectable items.
    *   Batch write to the `report_utilities` collection.

### Key Considerations for Import:

*   **Data Cleansing**: Cleanse data in CSVs before import if possible.
*   **`appraisal_id` Consistency**: Ensure `appraisal_id` is consistently used.
*   **Testing**: Test import scripts thoroughly on a development/staging Firebase project.
*   **Backup**: Ensure backups of CSV data.